AEGISTRACE 全栈技术指导（多平台 14 步版）
================================================

目标
----
- 一套主线（Rust Core + Verifier）保证三端一致
- 平台采集独立推进，但输出必须同格式、同 verifier 验证
- 每一步都有明确验收标准（做完就能判断对不对）

0) 总体架构与边界
----------------
四层架构（必须坚持）
1) Rust Core（共享）
   - 证据包写入、事件序列化、manifest、哈希链（防篡改）
2) Rust Verifier（共享 CLI）
   - 第三方独立验证 PASS/FAIL（结构/seq/hash/文件）
3) Collectors（平台原生）
   - macOS（Swift）、Windows（C#/.NET 或 C++）、Linux（Rust/C）
4) UI 壳（Tauri 可选）
   - Start/Stop、路径、状态、错误提示、导出报告（后置也行）

合规/隐私原则（写进 spec 和 README）
- 只用于本人设备自证
- 所有敏感权限通过系统弹窗明确授权
- 输入只记录元数据统计（默认不存明文）
- 网络默认记录域名级（不抓内容）且建议后置实现
- 证据包必须能被 verifier 独立验证


1) 推荐仓库结构（单主分支 + 目录分平台）
----------------------------------------
建议从“三分支”迁移到 main 单主线（分支用于短期 feature/bugfix，而不是按 OS 永久分裂）：

AEGISTRACE/
  crates/
    aegis-core/            # Rust：session、events、manifest、hash链
    aegis-verifier/        # Rust：verify 命令、PASS/FAIL、定位断点
    aegis-ipc/             # IPC协议（可选，先用纯JSON也可）
  apps/
    aegis-tauri/           # GUI（可选）
  collectors/
    macos/                 # Swift：采集
    windows/               # C#/.NET 或 C++：采集
    linux/                 # Rust/C：采集
  spec/
    evidence_bundle.md     # 对外规范（证据包格式/隐私说明/验证方式）
  scripts/
    build_macos.sh
    build_windows.ps1
    build_linux.sh


2) 证据包（Evidence Bundle）规范（所有平台必须一致）
--------------------------------------------------
目录结构（固定）
Evidence_YYYYMMDD_HHMMSS/
  session.json
  events.jsonl
  manifest.json
  files/
    screen.mp4 / screen.mkv / screen.mov   # 可选
    shots/                                  # 可选

events.jsonl（每行一个事件）
- 最小字段：
  - seq：严格递增（从 1 开始）
  - ts：UTC ISO8601
  - type：事件类型（字符串）
  - payload：JSON object
- 防篡改字段（Step 6 开始加入）：
  - prev_hash
  - hash

统一事件类型（跨平台对齐）
- session_started { save_dir, platform, app_version }
- session_stopped { reason }
- app_focus_changed { app_id, app_name, window_title? }
- file_added { rel_path, kind }
- shot_saved { rel_path }
- input_stats { interval_ms, key_count, backspace_count, paste_count, idle_bins... }
- net_domain { domain, app_id?, direction }（后置）

manifest.json（文件清单）
- events_hash（events.jsonl 总 hash）
- final_hash（最后事件 hash）
- files：每个文件的 hash（路径+hash）


3) IPC 设计（Collectors → Rust Core）
------------------------------------
MVP 推荐：本地 TCP 127.0.0.1 + JSON
理由：跨语言/跨平台最省事，调试最简单。

消息格式示例：
{ "type": "app_focus_changed", "payload": { "app_id": "...", "app_name": "..." } }

后续增强：mac/linux unix socket + windows named pipe（不建议一开始就做复杂）


4) 多平台 14 步开发路线（每步可验证）
------------------------------------
节奏：先把共享地基做硬（Spec/Core/Verifier），再三端采集并行推进。
从 Step 3 起，每一步的验收标准都应包含：verifier 能跑。

Phase 0：规范与骨架
------------------
Step 1 — 统一证据包规范（Spec-first）
交付：
- spec/evidence_bundle.md：目录结构、事件字段、事件类型、隐私声明
- 一个“最小样例 bundle”（手工生成也可）
验证：
- 能清楚解释：三端怎么输出同一格式、第三方怎么验证

Step 2 — Rust Core：Session + JSONL 写入（无防篡改）
交付：
- start_session(save_dir)：创建 Evidence_*
- append_event(type,payload)：写 events.jsonl、seq++
- stop_session()：写 session end
验证：
- 运行 demo：Start→写2条→Stop
- 文件落地正确：session.json、events.jsonl

Step 3 — Rust Verifier v0：结构 + seq 连续
交付：
- aegis-verifier verify <bundle_path> 输出 PASS/FAIL
- --json（可选先不做，后面做）
验证：
- 原始 PASS
- 删一行 events → FAIL，并指出 seq 断点


Phase 1：三平台采集最小对齐
--------------------------
Step 4 — 三端 Collector MVP：只接 Start/Stop
交付：
- macOS/Windows/Linux 各一个最小可运行 collector（哪怕 CLI）
- Start/Stop 调 core 生成 bundle
验证：
- 三端都能生成 bundle，verifier PASS

Step 5 — 三端前台应用/窗口焦点（统一事件 app_focus_changed）
交付：
- 三端都能写 app_focus_changed
验证：
- 切换 3 个应用（浏览器/编辑器/终端）
- events.jsonl 出现事件（3 端都要）
备注：
- Linux 桌面环境差异大，先选定一个目标环境跑通（例如 Ubuntu GNOME）


Phase 2：防篡改与可复现（先让证据“站得住”）
----------------------------------------
Step 6 — 防篡改 MVP：哈希链（跨平台一致算法）
交付：
- events 每行加入 prev_hash/hash
- session 结束写 final_hash（manifest 也记录）
验证：
- 原始 PASS
- 改一字符 → verifier FAIL，定位断链点

Step 7 — Verifier v1：哈希链 + 文件存在校验
交付：
- verifier 校验 hash chain
- 校验 files/ 文件存在性
验证：
- 删除录屏文件/截图文件 → FAIL


Phase 3：屏幕证据（三端分别实现，但统一 file_added 事件）
----------------------------------------------------
Step 8 — macOS 录屏 MVP（先能录出文件）
交付：
- 输出 files/screen.*
- 写事件 file_added { rel_path:"files/screen.mp4", kind:"screen_recording" }
验证：
- 视频可播放
- verifier PASS

Step 9 — Windows 录屏 MVP
交付与验证同 Step 8（输出可为 mp4/mkv/mov，rel_path 与 kind 统一）

Step 10 — Linux 录屏 MVP
交付与验证同 Step 8


Phase 4：证据质量提升（跨平台统一事件，平台实现逐步增强）
--------------------------------------------------
Step 11 — 截图/关键帧（shots）
交付：
- files/shots/000001.jpg...
- shot_saved 事件
验证：
- shots 数量与日志一致
- verifier PASS

Step 12 — 输入元数据统计（不存明文）
交付：
- input_stats 事件（每 10s 或 30s 汇总一次）
- 仅计数/分布，不写明文
验证：
- 打字/粘贴 → 有统计
- 日志无明文
- verifier PASS

Step 13 — 网络域名级（后置、最难）
交付：
- net_domain 事件
- 先做到“域名+时间”，再逐步做到“关联 app”
验证：
- 打开网站能看到域名记录
- verifier PASS


Phase 5：交付与发布
------------------
Step 14 — 打包与 CI：打 tag 自动出三端产物
交付：
- CI 矩阵构建三端产物
- release 附带 verifier（强烈建议）
验证：
- 打一个 tag → 三端产物自动上传
- 换机器用 verifier 验证 bundle：PASS/FAIL 一致


5) 工具选择建议（按所选栈）
--------------------------
Rust Core/Verifier
- hash：SHA-256（跨平台一致）
- canonical JSON：必须固定（键排序、编码一致）
- 输出：文本 + --json（给 GUI/报告消费）

GUI（Tauri）
- 先做 UI（路径 + Start/Stop + 状态）
- 不做复杂业务逻辑：UI 只负责调用 core，并展示 verifier 结果

Collectors
- macOS：Swift（权限/录屏/输入最顺）
- Windows：优先 C#/.NET（开发快、与系统 API 集成较舒服）
- Linux：Rust/C（取决于目标桌面环境）


6) 下一步建议（最稳顺序）
------------------------
1) Step 1–3：Spec + Rust Core + Verifier v0（先把地基打牢）
2) Step 4–5：三端 Collector 先做到 Start/Stop + app_focus_changed
3) Step 6–7：哈希链 + verifier 强化
4) Step 8–10：三端录屏（平台差异大，但此时已不怕返工）
